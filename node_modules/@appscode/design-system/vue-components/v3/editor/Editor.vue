<script setup lang="ts">
import { defineAsyncComponent, ref, computed, watch } from "vue";

interface Props {
  modelValue?: string;
  originalValue?: string;
  readOnly?: boolean;
  language?: string;
  showMinimap?: boolean;
  editorHeight?: number | string;
  editorTheme?: string;
  wordWrap?: string;
  validation?: {
    schema?: Record<string, unknown>;
    uri: string;
  };
}

const props = withDefaults(defineProps<Props>(), {
  modelValue: "",
  originalValue: "",
  readOnly: false,
  language: "",
  showMinimap: false,
  editorHeight: 40,
  editorTheme: "",
  wordWrap: "on",
  validation: () => ({ uri: "" }),
});

const emit = defineEmits(["update:modelValue"]);

const EditorTabs = defineAsyncComponent(() => import("../tabs/EditorTabs.vue"));

const Preloader = defineAsyncComponent(() => import("../preloader/Preloader.vue"));

const Banner = defineAsyncComponent(() => import("../banner/Banner.vue"));

const MonacoEditor = defineAsyncComponent({
  loader: () => import("./MonacoEditor.vue"),

  loadingComponent: Preloader,
  delay: 200,
  errorComponent: Banner,
  timeout: 100000,
});

const activeTab = ref("edit");
const editorContent = ref("");
const originalEditorContent = ref("");

const calcShowMinimap = computed(() => {
  const noOfLines = editorContent.value.split("\n").length;
  return props.showMinimap && noOfLines > 25;
});

const theme = computed(() => {
  return props.editorTheme || (document.documentElement.classList.contains("is-dark-theme") ? "vs-dark" : "vs");
});

const onChange = (e: Event) => {
  if (typeof e === "string") editorContent.value = e;
};

const onEditorMount = (editor: Record<string, unknown>) => {
  // add event listeners
  if (editor.onDidBlurEditorText instanceof Function) {
    editor.onDidBlurEditorText(() => {
      emit("update:modelValue", editorContent.value);
    });
  }
};

const computeHightInClass = computed(() => {
  if (typeof props.editorHeight === "number") return `vh-${props.editorHeight}`;
  else return "";
});

const computeHightInStyle = computed(() => {
  if (typeof props.editorHeight === "string") return { height: props.editorHeight };
  else return {};
});

watch(
  () => props.modelValue,
  (n) => {
    if (editorContent.value !== n) {
      editorContent.value = n;
    }
  },
  {
    immediate: true,
  }
);

watch(
  () => props.originalValue,
  (n) => {
    if (originalEditorContent.value !== n) {
      originalEditorContent.value = n;
    }
  },
  {
    immediate: true,
  }
);
</script>

<template>
  <div>
    <editor-tabs v-if="!readOnly" @tabchange="activeTab = $event" :active-tab="activeTab" />
    <monaco-editor
      v-if="activeTab === 'edit'"
      @editorDidMount="onEditorMount"
      key="edit"
      class="is-clipped"
      :class="computeHightInClass"
      :style="computeHightInStyle"
      :value="editorContent"
      @change="onChange"
      :language="language"
      :options="{
        minimap: {
          enabled: calcShowMinimap,
        },
        theme: theme,
        readOnly: readOnly,
        wordWrap: wordWrap,
        scrollBeyondLastLine: false,
      }"
      :validation="validation"
      data-testid="monaco-editor-edit-section"
    />
    <monaco-editor
      v-if="activeTab === 'preview'"
      key="preview"
      class="is-clipped"
      :class="computeHightInClass"
      :style="computeHightInStyle"
      :value="editorContent"
      :language="language"
      :options="{
        minimap: {
          enabled: calcShowMinimap,
        },
        theme: theme,
        readOnly: true,
        wordWrap: wordWrap,
        scrollBeyondLastLine: false,
      }"
      :original="originalEditorContent"
      :diff-editor="true"
      :validation="validation"
      data-testid="monaco-editor-preview-section"
    />
  </div>
</template>
